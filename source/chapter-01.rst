#################################
Chapter 1. Inductive Sets of Data
#################################

Exercise 1.1
============

#.  :math:`\{3n + 2 \mid n \in N\}`

    Top-down:
        A natural number :math:`n` is in :math:`S` if and only if

        #.  :math:`n = 2`, or
        #.  :math:`n - 3 \in S`.

    Bottom-up:
        Define the set :math:`S` to be the smallest set contained in :math:`N` and satisfying the following two properties:

        #.  :math:`2 \in S`
        #.  if :math:`n \in S`, then :math:`n + 3 \in S`

    Rules of inference:
        .. math::

            2 \in S

            \frac {
                n \in S
            } {
                n + 3 \in S
            }

#.  :math:`\{2n + 3m + 1 \mid n, m \in N\}`

    Top-down:
        A natural number :math:`n` is in :math:`S` if and only if

        #.  :math:`n = 1`, or
        #.  :math:`n - 2 \in S`, or
        #.  :math:`n - 3 \in S`

    Bottom-up:
        Define the set :math:`S` to be the smallest set contained in :math:`N` and satisfying the following two properties:

        #.  :math:`1 \in S`
        #.  if :math:`n \in S`, then :math:`n + 2 \in S` and :math:`n + 3 \in S`

    Rules of inference:
        .. math::

            1 \in S

            \frac {
                n \in S
            } {
                n + 2 \in S,
                n + 3 \in S
            }

#.  :math:`\{(n, 2n + 1) \mid n \in N\}`

    Top-down:
        A pair of natural numbers :math:`(n, m)` is in :math:`S` if and only if

        #.  :math:`n = 0` and :math:`m = 1`, or
        #.  :math:`(n - 1, m - 2) \in S`

    Bottom-up:
        Define the set :math:`S` to be the smallest set contained in :math:`\{n, m \mid n \in N, m \in N\}` and satisfying the following two properties:

        #.  :math:`(0, 1) \in S`
        #.  if :math:`(n, m) \in S`, then :math:`(n + 1, m + 2) \in S`

    Rules of inference:
        .. math::

            (0, 1) \in S

            \frac {
                (n, m) \in S
            } {
                (n + 1, m + 2) \in S
            }

#.  :math:`\{(n, n^2 \mid n \in N)\}`

    Top-down:
        A pair of natural numbers :math:`(n, m)` is in :math:`S` if and only if

        #.  :math:`n = 0`, and :math:`m = 0`, or
        #.  :math:`(n - 1, m - 2n + 1) \in S`

    Bottom-up:
        Define the set :math:`S` to be the smallest set contained in :math:`\{n, m \mid n \in N, m \in N\}` and satisfying the following two properties:

        #.  :math:`(0, 0) \in S`
        #.  if :math:`(n, m) \in S`, then :math:`(n + 1, m + 2n + 1) \in S`

    Rules of inference:
        .. math::

            (0, 0) \in S

            \frac {
                (n, m) \in S
            } {
                (n + 1, m + 2n + 1) \in S
            }

Exercise 1.2
============

#.  :math:`(0, 1) \in S \quad \displaystyle \frac{(n, k) \in S}{(n + 1, k + 7) \in S}`

    .. math::

        \{(n, 7n + 1) \mid n \in N\}

#.  :math:`(0, 1) \in S \quad \displaystyle \frac{(n, k) \in S}{(n + 1, 2k) \in S}`

    .. math::

        \{(n, 2^n) \mid n \in N\}

#.  :math:`(0, 0, 1) \in S \quad \displaystyle \frac{(n, i, j) \in S}{(n + 1, j, i + j) \in S}`

    .. math::

        \{(n, F(n), F(n + 1)) \mid n \in N\}

    where :math:`F(n)` is defined as

    .. math::

        F(n) =
            \begin{cases}
                0 & n = 0 \\
                1 & n = 1 \\
                F(n - 1) + F(n - 2), & n > 1
            \end{cases}

#.  :math:`(0, 1, 0) \in S \quad \displaystyle \frac{(n, i, j) \in S}{(n + 1, i + 2, i + j) \in S}`

    .. math::

        \{(n, 2n + 1, n^2 \mid n \in N\}

    Proof:
        Let :math:`(n_k, i_k, j_k)` be the :math:`k`-th element of :math:`S` generated by the rules of inference. Then we have:

        .. math::

            n_0 &= 0 \\
            n_k &= n_{k-1} + 1 = n_{k-1} + 1 \times 1 \\
                &= n_{k-2} + 1 + 1 = n_{k-2} + 2 \times 1 \\
                &= n_{k-k} + 1 + \dots + 1 = n_{k-k} + k \times 1 \\
                &= n_0 + k \times 1 \\
                &= k

        and

        .. math::

            i_0 &= 1 \\
            i_k &= i_{k-1} + 2 = i_{k-1} + 1 \times 2 \\
                &= i_{k-2} + 2 + 2 = i_{k-1} + 2 \times 2 \\
                &= i_{k-k} + 2 + \dots + 2 = i_{k-k} + k \times 2 \\
                &= i_0 + 2k \\
                &= 2k + 1

        and

        .. math::

            j_0 &= 0 \\
            j_k &= i_{k-1} + j_{k-1} \\
                &= 2(k - 1) + 1 + j_{k-1} \\
                &= 2(k - 1) + 1 + i_{k-2} + j_{k-2} \\
                &= 2(k - 1) + 1 + 2(k - 2) + 1 + j_{k-2} \\
                &= 2(k - 1) + 1 + 2(k - 2) + 1 + \dots + 2(k - k) + 1 + j_{k-k} \\
                &= \left ( \sum_{x=1}^k 2(k - x) + 1 \right ) + j_0 \\
                &= 2 \left ( k^2 - \frac{(1 + k)k}{2} \right ) + k \\
                &= 2k^2 - (1 + k)k + k \\
                &= 2k^2 - k - k^2 + k \\
                &= k^2

        Thus we have

        .. math::

            S = \{ (n, 2n + 1, n^2) \mid n \in N \}

        Q.E.D.

Exercise 1.3
============

.. math::

    0 \in T

    1 \in T

    \frac {
        n \in T
    } {
        n + 3 \in T
    }

Exercise 1.4
============

::

        List-of-Int
    =>  (Int . List-of-Int)
    =>  (-7 . List-of-Int)
    =>  (-7 . (Int . List-of-Int))
    =>  (-7 . (3 . List-of-Int))
    =>  (-7 . (3 . (Int . List-of-Int)))
    =>  (-7 . (3 . (14 . List-of-Int)))
    =>  (-7 . (3 . (14 . ())))

Exercise 1.5
============

Proof:
    This proof is by induction on the depth of :math:`e`. The depth of :math:`e`, :math:`d(e)`, is defined as follows:

    #.  If :math:`e` is :math:`Identifier`, :math:`d(e) = 1`
    #.  If :math:`e` is :math:`\texttt{(lambda (}Identifier\texttt{) }e_1\texttt{)}`, :math:`d(e) = d(e_1) + 1`
    #.  If :math:`e` is :math:`\texttt{(}e_1, e_2\texttt{)}`, :math:`d(e) = \textrm{max}(d(e_1, e_2)`

    The induction hypothesis, :math:`IH(k)`, is that for any :math:`e \in LcExp` of depth :math:`\leq k` has the same number of left and right parentheses.

    #.  There are no such :math:`e` that :math:`d(e) = 0`, so :math:`IH(0)` holds trivially.
    #.  Let :math:`k` be an integer such that :math:`IH(k)` holds.

        -   If :math:`e` is :math:`Identifier`, we have :math:`k = 1`, and there are no parentheses. So :math:`IH(1)` holds.
        -   If :math:`e` is :math:`\texttt{(lambda (}Identifier\texttt{) }e_1\texttt{)}`, we have :math:`k = d(e_1) + 1`. Since :math:`d(e_1) < k`, :math:`IH(d(e_1))` holds, i.e., :math:`e_1` have the same number of left and right parentheses. Since :math:`e` adds exactly two left parentheses and two right parentheses, :math:`IH(k)` holds.
        -   If :math:`e` is :math:`\texttt{(}e_1, e_2\texttt{)}`, :math:`d(e) = \textrm{max}(d(e_1, e_2)`, we have :math:`k = \textrm{max}(e_1, e_2)`. Since :math:`d(e_1) < k`, :math:`IH(d(e_1)` holds. Similarly, :math:`IH(d(e_2))` holds. Since :math:`e` adds one left parenthesis and one right parenthesis to :math:`e_1 e_2`, :math:`IH(k)` holds

    Q.E.D.

Exercise 1.6
============

The procedure may crash when given an empty list because we are trying to apply ``car`` to ``'()``.

Exercise 1.7
============

.. literalinclude:: 01-07.scm
    :language: scheme
    :linenos:

Exercise 1.8
============

If the last line is replaced, this procedure drops the first occurrence of ``s`` together with all the elements before it::

    drop-until : Sym x Listof(Sym) -> Listof(Sym)
    usage: (drop-until s los) returns a list with the same
           elements arranged in the same order as los,
           except that the first occurrence of the symbol s
           and all elements before it are removed.

Exercise 1.9
============

.. literalinclude:: 01-09.scm
    :language: scheme
    :linenos:

Exercise 1.10
=============

Exclusive or, or "xor".

Exercise 1.11
=============

The thing that gets smaller is the number of occurrences of ``old``.

Exercise 1.12
=============

.. literalinclude:: 01-12.scm
    :language: scheme
    :linenos:

Exercise 1.13
=============

.. literalinclude:: 01-13.scm
    :language: scheme
    :linenos:

Exercise 1.14
=============

Proof:
    Translated to mathematical language, ``partial-vector-sum`` is equivalent to the following function :math:`f(n)`:

    .. math::

        f(n) =
            \begin{cases}
                v_0            & n = 0 \\
                v_n + f(n - 1) & n > 0
            \end{cases}

    Let's prove by induction on :math:`n`. The induction hypothesis :math:`IH(k)`, is

    .. math::

        f(n) = \sum_{i = 0}^{n}{v_i}

    #.  When :math:`k = 0`, :math:`IH(k)` holds because :math:`f(0) = v_0`.
    #.  When :math:`k > 0`, we have

        .. math::

            f(k) = v_k + f(k - 1)

        Since :math:`IH(k - 1)` holds, we have

        .. math::

            f(k) = v_k + \sum_{i = 0}^{k - 1}{v_i} = \sum_{i = 0}^{k}{v_i}

    Q.E.D.

Exercise 1.15
=============

.. literalinclude:: 01-15.scm
    :language: scheme
    :linenos:

Exercise 1.16
=============

.. literalinclude:: 01-16.scm
    :language: scheme
    :linenos:

Exercise 1.17
=============

.. literalinclude:: 01-17.scm
    :language: scheme
    :linenos:

Exercise 1.18
=============

.. literalinclude:: 01-18.scm
    :language: scheme
    :linenos:

Exercise 1.19
=============

.. literalinclude:: 01-19.scm
    :language: scheme
    :linenos:

Exercise 1.20
=============

.. literalinclude:: 01-20.scm
    :language: scheme
    :linenos:

Exercise 1.21
=============

.. literalinclude:: 01-21.scm
    :language: scheme
    :linenos:

Exercise 1.22
=============

.. literalinclude:: 01-22.scm
    :language: scheme
    :linenos:

Exercise 1.23
=============

.. literalinclude:: 01-23.scm
    :language: scheme
    :linenos:

Exercise 1.24
=============

.. literalinclude:: 01-24.scm
    :language: scheme
    :linenos:

Exercise 1.25
=============

.. literalinclude:: 01-25.scm
    :language: scheme
    :linenos:

Exercise 1.26
=============

.. literalinclude:: 01-26.scm
    :language: scheme
    :linenos:

Exercise 1.27
=============

.. literalinclude:: 01-27.scm
    :language: scheme
    :linenos:

Exercise 1.28
=============

.. literalinclude:: 01-28.scm
    :language: scheme
    :linenos:

Exercise 1.29
=============

.. literalinclude:: 01-29.scm
    :language: scheme
    :linenos:

Exercise 1.30
=============

.. literalinclude:: 01-30.scm
    :language: scheme
    :linenos:

Exercise 1.31
=============

.. literalinclude:: 01-31.scm
    :language: scheme
    :linenos:

Exercise 1.32
=============

.. literalinclude:: 01-32.scm
    :language: scheme
    :linenos:

Exercise 1.33
=============

.. literalinclude:: 01-33.scm
    :language: scheme
    :linenos:

Exercise 1.34
=============

.. literalinclude:: 01-34.scm
    :language: scheme
    :linenos:

Exercise 1.35
=============

.. literalinclude:: 01-35.scm
    :language: scheme
    :linenos:

Exercise 1.36
=============

.. literalinclude:: 01-36.scm
    :language: scheme
    :linenos:
